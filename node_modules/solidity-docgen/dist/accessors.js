"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accessors = exports.wrapWithAccessors = void 0;
const utils_1 = require("solidity-ast/utils");
const natspec_1 = require("./utils/natspec");
const map_values_1 = require("./utils/map-values");
const doc_item_1 = require("./doc-item");
/**
 * Returns a new object with all of the item properties plus the accessors
 * applied to the item. The accessors are not reflected in the return type
 * because we assume they are only used in templates, which are untyped anyway.
 */
function wrapWithAccessors(item) {
    return {
        ...item,
        ...(0, map_values_1.mapValues)(exports.accessors, fn => fn(item)),
    };
}
exports.wrapWithAccessors = wrapWithAccessors;
function getParams(params, natspec) {
    return params.parameters.map((p, i) => {
        var _a;
        return ({
            name: p.name,
            type: p.typeDescriptions.typeString,
            natspec: (_a = natspec === null || natspec === void 0 ? void 0 : natspec.find((q, j) => q.name === undefined ? i === j : p.name === q.name)) === null || _a === void 0 ? void 0 : _a.description,
        });
    });
}
function formatVariable(v) {
    var _a;
    return [(_a = v.typeName) === null || _a === void 0 ? void 0 : _a.typeDescriptions.typeString].concat(v.name || []).join(' ');
}
exports.accessors = {
    type(item) {
        return item.nodeType
            .replace(/(Definition|Declaration)$/, '')
            .replace(/(\w)([A-Z])/g, '$1 $2');
    },
    natspec(item) {
        return (0, natspec_1.parseNatspec)(item);
    },
    name(item) {
        if (item.nodeType === 'FunctionDefinition') {
            return item.kind === 'function' ? item.name : item.kind;
        }
        else {
            return item.name;
        }
    },
    signature(item) {
        switch (item.nodeType) {
            case 'ContractDefinition':
                return undefined;
            case 'FunctionDefinition': {
                const { kind, name } = item;
                const params = item.parameters.parameters;
                const returns = item.returnParameters.parameters;
                const head = (kind === 'function' || kind === 'freeFunction') ? [kind, name].join(' ') : kind;
                let res = [
                    `${head}(${params.map(formatVariable).join(', ')})`,
                    item.visibility,
                ];
                if (item.stateMutability !== 'nonpayable') {
                    res.push(item.stateMutability);
                }
                if (item.virtual) {
                    res.push('virtual');
                }
                if (returns.length > 0) {
                    res.push(`returns (${returns.map(formatVariable).join(', ')})`);
                }
                return res.join(' ');
            }
            case 'EventDefinition': {
                const params = item.parameters.parameters;
                return `event ${item.name}(${params.map(formatVariable).join(', ')})`;
            }
            case 'ErrorDefinition': {
                const params = item.parameters.parameters;
                return `error ${item.name}(${params.map(formatVariable).join(', ')})`;
            }
            case 'ModifierDefinition': {
                const params = item.parameters.parameters;
                return `modifier ${item.name}(${params.map(formatVariable).join(', ')})`;
            }
            case 'VariableDeclaration':
                return formatVariable(item);
        }
    },
    params(item) {
        if ('parameters' in item) {
            const natspec = exports.accessors.natspec(item);
            return getParams(item.parameters, natspec.params);
        }
    },
    returns(item) {
        if ('returnParameters' in item) {
            const natspec = exports.accessors.natspec(item);
            return getParams(item.returnParameters, natspec.returns);
        }
    },
    items(item) {
        return (item.nodeType === 'ContractDefinition')
            ? item.nodes.filter((0, utils_1.isNodeType)(doc_item_1.docItemTypes))
            : undefined;
    },
    functions(item) {
        return [...(0, utils_1.findAll)('FunctionDefinition', item)];
    },
    events(item) {
        return [...(0, utils_1.findAll)('EventDefinition', item)];
    },
    modifiers(item) {
        return [...(0, utils_1.findAll)('ModifierDefinition', item)];
    },
    errors(item) {
        return [...(0, utils_1.findAll)('ErrorDefinition', item)];
    },
    variables(item) {
        return (item.nodeType === 'ContractDefinition')
            ? item.nodes.filter((0, utils_1.isNodeType)('VariableDeclaration')).filter(v => v.stateVariable)
            : undefined;
    },
    types(item) {
        return [...(0, utils_1.findAll)(['StructDefinition', 'EnumDefinition', 'UserDefinedValueTypeDefinition'], item)];
    },
};
//# sourceMappingURL=accessors.js.map